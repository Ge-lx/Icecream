{"version":3,"sources":["net/websocket.js"],"names":["tokens","clients","wss","startServer","server","cfg","Promise","resolve","reject","console","log","Server","shouldHandle","req","spliturl","url","split","length","hasOwnProperty","on","socket","token","user","addClient","isConnected","stopServer","close","getClientToken","randomBytes","toString","client","broadcast","json","Object","keys","forEach","element","sendMessage","updateChanges","msg","action","payload","getClientList","module","exports"],"mappings":";;AAAA;;;;AACA;;;;AACA;;;;;;AAEA,IAAIA,SAAS,EAAb,C,CAAgB;AAChB,IAAIC,UAAU,EAAd,C,CAAiB;AACjB,IAAIC,MAAM,IAAV,C,CAAe;;AAEf;AACA,IAAMC,cAAc,SAAdA,WAAc,CAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AACzC,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCC,YAAQC,GAAR,CAAY,8BAAZ;;AAEAR,UAAM,IAAI,aAAUS,MAAd,CAAqB,EAAEP,QAAQA,MAAV,EAArB,CAAN;;AAEA;AACAF,QAAIU,YAAJ,GAAmB,UAAUC,GAAV,EAAe;AAChC,UAAIC,WAAWD,IAAIE,GAAJ,CAAQC,KAAR,CAAc,GAAd,CAAf,CADgC,CACE;AAClC,aAAOF,SAASG,MAAT,GAAkB,CAAlB,IAAuBjB,OAAOkB,cAAP,CAAsBJ,SAAS,CAAT,CAAtB,CAA9B;AACD,KAHD;;AAKAZ,QAAIiB,EAAJ,CAAO,WAAP,EAAoBZ,OAApB,EAXsC,CAWT;;AAE7B;AACAL,QAAIiB,EAAJ,CAAO,YAAP,EAAqB,UAAUC,MAAV,EAAkBP,GAAlB,EAAuB;AAC1C,UAAIQ,QAAQR,IAAIE,GAAJ,CAAQC,KAAR,CAAc,GAAd,EAAmB,CAAnB,CAAZ;AACA,UAAIM,OAAOtB,OAAOqB,KAAP,CAAX;AACAE,gBAAUD,IAAV,EAAgBF,MAAhB;AACA,aAAOpB,OAAOqB,KAAP,CAAP;AACD,KALD;;AAOAnB,QAAIiB,EAAJ,CAAO,OAAP,EAAgBX,MAAhB;AACD,GAtBM,CAAP;AAuBD,CAxBD;;AA0BA,IAAMgB,cAAc,SAAdA,WAAc,GAAY;AAC9B,SAAOtB,QAAQ,IAAf;AACD,CAFD;;AAIA,IAAMuB,aAAa,SAAbA,UAAa,GAAY;AAC7B,SAAO,IAAInB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtCN,QAAIwB,KAAJ,CAAUnB,OAAV;AACD,GAFM,CAAP;AAGD,CAJD;;AAMA;AACA,IAAMoB,iBAAiB,SAAjBA,cAAiB,CAAUL,IAAV,EAAgB;AACrC,MAAID,QAAQ,iBAAOO,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,KAAhC,CAAZ;AACA7B,SAAOqB,KAAP,IAAgBC,IAAhB;AACA,SAAOD,KAAP;AACD,CAJD;;AAMA;AACA,IAAME,YAAY,SAAZA,SAAY,CAAUD,IAAV,EAAgBF,MAAhB,EAAwB;AACxC;AACA,MAAInB,QAAQiB,cAAR,CAAuBI,IAAvB,CAAJ,EAAkC;AAChCb,YAAQC,GAAR,CAAY,+BAA+BY,IAA/B,GAAsC,qBAAlD;AACArB,YAAQqB,IAAR,EAAcI,KAAd;AACD,GAHD,MAGO;AACLjB,YAAQC,GAAR,CAAY,yBAAyBY,IAArC;AACD;;AAED,MAAIQ,SAAS,+BAAqBR,IAArB,EAA2BF,MAA3B,EAAmC,YAAM;AACpD;AACAX,YAAQC,GAAR,CAAYY,OAAO,gBAAnB;AACA,WAAOrB,QAAQqB,IAAR,CAAP;AACD,GAJY,CAAb;AAKArB,UAAQqB,IAAR,IAAgBQ,MAAhB,CAdwC,CAcjB;AACxB,CAfD;;AAiBA;AACA,IAAMC,YAAY,SAAZA,SAAY,CAAUC,IAAV,EAAgB;AAChCC,SAAOC,IAAP,CAAYjC,OAAZ,EAAqBkC,OAArB,CAA6B,UAAUC,OAAV,EAAmB;AAC9CnC,YAAQmC,OAAR,EAAiBC,WAAjB,CAA6BL,IAA7B;AACD,GAFD;AAGD,CAJD;;AAMA,IAAMM,gBAAgB,SAAhBA,aAAgB,GAAY;AAChC,MAAIC,MAAM;AACRC,YAAQ,aADA;AAERC,aAAS;AAFD,GAAV;AAIAV,YAAUQ,GAAV;AACD,CAND;;AAQA,IAAMG,gBAAgB,SAAhBA,aAAgB,GAAY;AAChC,SAAOzC,OAAP;AACD,CAFD;;AAIA0C,OAAOC,OAAP,GAAiB;AACfzC,eAAaA,WADE;AAEfsB,cAAYA,UAFG;AAGfE,kBAAgBA,cAHD;AAIfe,iBAAeA,aAJA;AAKflB,eAAaA,WALE;AAMfO,aAAWA,SANI;AAOfO,iBAAeA;AAPA,CAAjB","file":"websocket.js","sourcesContent":["import WebSocket from 'ws'\r\nimport crypto from 'crypto'\r\nimport ClientConnection from './clientConnection'\r\n\r\nvar tokens = {} // Token list { user: token, ...}\r\nvar clients = {} // Connected clients { user: Handler, ...}\r\nvar wss = null // WebSocket Server\r\n\r\n// Starts the websocket / sets up handlers\r\nconst startServer = function (server, cfg) {\r\n  return new Promise((resolve, reject) => {\r\n    console.log('Starting webSocket server...')\r\n\r\n    wss = new WebSocket.Server({ server: server })\r\n\r\n    // Checks if the supplied token is in token list\r\n    wss.shouldHandle = function (req) {\r\n      var spliturl = req.url.split('/') // Get token from request url\r\n      return spliturl.length > 2 && tokens.hasOwnProperty(spliturl[2])\r\n    }\r\n\r\n    wss.on('listening', resolve) // Resolve when server is ready\r\n\r\n    // Valid connection, checked before. Handle connection, delete token\r\n    wss.on('connection', function (socket, req) {\r\n      var token = req.url.split('/')[2]\r\n      var user = tokens[token]\r\n      addClient(user, socket)\r\n      delete tokens[token]\r\n    })\r\n\r\n    wss.on('error', reject)\r\n  })\r\n}\r\n\r\nconst isConnected = function () {\r\n  return wss !== null\r\n}\r\n\r\nconst stopServer = function () {\r\n  return new Promise((resolve, reject) => {\r\n    wss.close(resolve)\r\n  })\r\n}\r\n\r\n// Generate new token. Called by clients thourgh dashbaord.js (http)\r\nconst getClientToken = function (user) {\r\n  var token = crypto.randomBytes(32).toString('hex')\r\n  tokens[token] = user\r\n  return token\r\n}\r\n\r\n// Called when new client connects\r\nconst addClient = function (user, socket) {\r\n  // One connection per client.\r\n  if (clients.hasOwnProperty(user)) {\r\n    console.log('Duplicate connection from ' + user + '. Dropping old one.')\r\n    clients[user].close()\r\n  } else {\r\n    console.log('New connection from ' + user)\r\n  }\r\n\r\n  var client = new ClientConnection(user, socket, () => {\r\n    // This is the onClose function\r\n    console.log(user + ' disconnected.')\r\n    delete clients[user]\r\n  })\r\n  clients[user] = client // Save client\r\n}\r\n\r\n// Sends a message to all clients\r\nconst broadcast = function (json) {\r\n  Object.keys(clients).forEach(function (element) {\r\n    clients[element].sendMessage(json)\r\n  })\r\n}\r\n\r\nconst updateChanges = function () {\r\n  let msg = {\r\n    action: 'listChanges',\r\n    payload: null\r\n  }\r\n  broadcast(msg)\r\n}\r\n\r\nconst getClientList = function () {\r\n  return clients\r\n}\r\n\r\nmodule.exports = {\r\n  startServer: startServer,\r\n  stopServer: stopServer,\r\n  getClientToken: getClientToken,\r\n  getClientList: getClientList,\r\n  isConnected: isConnected,\r\n  broadcast: broadcast,\r\n  updateChanges: updateChanges\r\n}\r\n"]}