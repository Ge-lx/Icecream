{"version":3,"sources":["net/websocket.js"],"names":["tokens","sesskeys","clients","wss","startServer","server","cfg","Promise","resolve","reject","Server","shouldHandle","req","spliturl","url","split","length","hasOwnProperty","on","console","log","socket","token","user","sess","key","onConnect","addClient","isConnected","stopServer","close","getClientToken","randomBytes","toString","id","getSessionKey","onMessage","onClose","client","external","broadcast","json","Object","keys","forEach","element","sendMessage","updateChanges","msg","action","payload","getClientList","module","exports"],"mappings":"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","file":"websocket.js","sourcesContent":["import WebSocket from 'ws'\r\nimport crypto from 'crypto'\r\nimport ClientConnection from './clientConnection'\r\n\r\nvar tokens = {} // Token list { token: user, ...}\r\nvar sesskeys = {} // Session keys { user: {key: 'SDFLKJF', callback: () => ...} }\r\nvar clients = {} // Connected clients { user: Handler, ...}\r\nvar wss = null // WebSocket Server\r\n\r\n// Starts the websocket / sets up handlers\r\nconst startServer = function (server, cfg) {\r\n  return new Promise((resolve, reject) => {\r\n    wss = new WebSocket.Server({ server: server })\r\n\r\n    // Checks if the supplied token is in token list\r\n    wss.shouldHandle = function (req) {\r\n      var spliturl = req.url.split('/') // Get token from request url\r\n      return spliturl.length > 2 && tokens.hasOwnProperty(spliturl[2])\r\n    }\r\n\r\n    wss.on('listening', () => {\r\n      console.log('WebSocket listening...')\r\n      resolve()\r\n    }) // Resolve when server is ready\r\n\r\n    // Valid connection, checked before. Handle connection, delete token\r\n    wss.on('connection', function (socket, req) {\r\n      var split = req.url.split('/')\r\n      var token = split[2]\r\n      var user = tokens[token]\r\n      var sess = sesskeys[user]\r\n      if (sess && sess.key === split[3]) {\r\n        sess.onConnect(addClient(user, socket, sess))\r\n      } else addClient(user, socket)\r\n      delete tokens[token]\r\n    })\r\n\r\n    wss.on('error', reject)\r\n  })\r\n}\r\n\r\nconst isConnected = function () {\r\n  return wss !== null\r\n}\r\n\r\nconst stopServer = function () {\r\n  return new Promise((resolve, reject) => {\r\n    wss.close(resolve)\r\n  })\r\n}\r\n\r\n// Generate new token. Called by clients thourgh dashbaord.js (http)\r\nconst getClientToken = function (user) {\r\n  var token = crypto.randomBytes(32).toString('hex')\r\n  tokens[token] = user.id\r\n  return token\r\n}\r\n\r\n// onConnect: (client) => {}, onClose: (client) => {}\r\nconst getSessionKey = function (user, onMessage, onConnect, onClose) {\r\n  var key = crypto.randomBytes(16).toString('hex')\r\n  sesskeys[user.id] = { key, onMessage, onConnect, onClose }\r\n  return key\r\n}\r\n\r\n// Called when new client connects\r\nconst addClient = function (user, socket, sess) {\r\n  // One connection per client.\r\n  if (clients.hasOwnProperty(user)) {\r\n    console.log('Duplicate connection from ' + user + '. Dropping old one.')\r\n    clients[user].close()\r\n  } else {\r\n    console.log('New connection from ' + user)\r\n  }\r\n\r\n  var client = new ClientConnection(user, socket, () => {\r\n    // This is the onClose function\r\n    if (sess.onClose) sess.onClose()\r\n    console.log(user + ' disconnected.')\r\n    delete clients[user]\r\n  })\r\n\r\n  client.external(sess.onMessage, sess.onClose)\r\n  clients[user] = client // Save client\r\n  return client\r\n}\r\n\r\n// Sends a message to all clients\r\nconst broadcast = function (json) {\r\n  Object.keys(clients).forEach(function (element) {\r\n    clients[element].sendMessage(json)\r\n  })\r\n}\r\n\r\nconst updateChanges = function () {\r\n  let msg = {\r\n    action: 'listChanges',\r\n    payload: null\r\n  }\r\n  broadcast(msg)\r\n}\r\n\r\nconst getClientList = function () {\r\n  return clients\r\n}\r\n\r\nmodule.exports = {\r\n  startServer: startServer,\r\n  stopServer: stopServer,\r\n  getClientToken: getClientToken,\r\n  getSessionKey: getSessionKey,\r\n  getClientList: getClientList,\r\n  isConnected: isConnected,\r\n  broadcast: broadcast,\r\n  updateChanges: updateChanges\r\n}\r\n"]}